---
title: Git reset 和 revert 的区别是什么？
category: 工程化与构建
date: 2025-07-08 12:45
difficulty: 中等
excerpt: Git 中的 `reset` 和 `revert` 是两种用于修改项目版本控制历史的方法，主要区别在于它们如何处理提交记录以及对工作区的影响。
tags:
- 版本控制
- Git
---
### git reset
`git reset` 移动当前分支的 `HEAD` 指针到指定提交历史位置, 可以丢弃或重置某些更改。它有以下模式:
- `git reset --soft`: 仅移动 `HEAD` 指针, 保留暂存区和工作目录的更改。
- `git reset --mixed` (默认模式): 移动 `HEAD` 并重置暂存区, 但保留工作目录的更改。
- `git reset --hard`: 移动 `HEAD`、重置暂存区和工作目录, 丢弃所有未提交的更改, **慎用可能永久丢失数据**。
适用场景: **撤销本地未推送的提交**（例如个人分支中的错误提交或暂存文件撤销）。例:
```bash
# 撤销本地工作区文件修改
git reset HEAD file.txt
# 硬重置到指定提交
git reset --hard commit_id
```

### git revert
`git revert` 创建新提交未撤销指定已有提交的更改，保留原本的历史提交记录, **用于已发布共享分支的撤销操作**。例:
```bash
# 撤销某个提交的历史提交 (e. g. )
git revert aabbcc1222
```
该操作生成反向更改的提交, 需人工解决潜在冲突在 commit conflict时出现.

### 核心区别
1. **对历史记录的影响**:
   - `reset` 移动 `HEAD` , 可能覆盖提交历史并丢失数据修改, **适合私有仓库和本地的操作**, 但不适用于已有推送到已发布历史.
   - `revert` 添加一个新内容, 保留原始提交历史, **不改变协作历史**。
2. **是否数据丢弃重写:** 
   - `reset`（尤其 `--hard`）可能强制修改内容或删除数据, 存在风险修改丢失风险.
   - `revert` 不修改已存在的版本历史, 只增更改操作日志; 操作更安全.
3. **分支使用场景**:
   - **公有已推送历史**: 严格用 `revert`（不重写历史）。
   - **未推送或开发中的新分支**: 可选 `reset` (便于灵活丢弃错误)。
4. **操作后果**:
   - 若操作三提交 (`A→B→C`)并取消 `B`:
     - `reset --hard B`: HEAD → `A`之后修改无效清除,只留存`A/B`的提交。状态重置为空状态.
     - `revert B`: 新的HEAD指向新提交撤销 `B`更改，结果树文件回滚`A`前状态, 仍记录`A/B/C`历史。新记录点出现追加新操作.
