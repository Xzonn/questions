---
title: 数据库死锁是如何产生的？
category: 算法与数据结构
date: 2025-07-09 11:57
difficulty: 中等
excerpt: 数据库死锁通常由多个事务在并发执行时竞争资源而产生。要解决这个问题，可以通过优化加锁策略、设置超时机制或采用死锁检测与恢复机制来避免。
tags:
- 数据库
- 事务
- 并发控制
---
数据库死锁通常发生在并发事务执行过程中，当多个事务相互等待对方持有的资源而无法前进时，导致系统挂起。这种情况本质上是资源竞争问题的表现。从参考内容中可以看出事务性数据库易受外部异常（如断电）影响，影响事务处理的完整性：。

数据库死锁的主要原因包括：
- **互斥资源竞争**：例如事务在读写锁场景，如某事务持有写锁并需要另一个锁，而其他事务已占有相同资源链。
- **持有与等待**：事务占用资源时不释放，还试图请求新资源： 提到的数据库在处理未提交操作时如遇中断会破坏原子性。
- **不可剥夺限制**：核心资源强制独占，事务需等待无法强制释放。

常见触发点如 SQL 事务并发中的行锁定冲突：
```sql
-- 事务 A 尝试更新行 X 后 Y，事务 B 反之，若执行顺序重叠产生死锁
BEGIN TRANSACTION;
UPDATE table SET column= value WHERE id = 1; -- 锁定 id=1
-- 等待其他锁被释放
COMMIT;
```

防治策略如：
1. **死锁检测与恢复**：提到故障后可 undo 退回以恢复一致性。
2. **超时机制**：设定事务最大运行期。
3. **按顺序请求资源**，优化加锁策略减少交错。

整体看，此问题突显数据库引擎设计的算法挑战，要求高可用系统确保资源竞争合理处理，避免死锁降低性能。
