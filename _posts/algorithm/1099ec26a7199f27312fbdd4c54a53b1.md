---
title: 如何在数组中找出三个数之和为 N？
category: 算法与数据结构
date: 2025-07-09 20:10
difficulty: 中等
excerpt: 寻找数组中所有唯一的三元组，使它们的和等于目标值 N。使用排序和双指针技巧优化算法时间复杂度至 O (n²)。
tags:
- 三数之和
- 算法
- 数组
---
这个问题是在给定数组中寻找所有唯一的三元组（三个数的组合），使它们的和恰好等于目标值 N。这种场景是经典的“三数之和”算法问题，常见于解决组合总和相关的面试题。高效的解法依赖于避免暴力法（时间复杂度 O(n^3)），而采用双指针方法，可将时间复杂度优化至 O(n^2)。以下是面试中最推荐的解法思路和实现。

解决思路：
- **排序数组**：对原数组排序后，可以利用数组的有序性高效缩小搜索范围。时间复杂度 O(n log n)。
- **遍历加双指针**：遍历固定数组中的某一个数作为三元组的第一个数后，使用左右双指针搜索余下的数组。
- **滑动搜索**：双指针从剩余的左右端点开始移动，根据当前总和与目标值的差值动态调整双指针。
- **去重机制**：在每一步跳过排序数组中连续重复数字，确保只收集不重复的三元组。

算法步骤：
1. **初始化结果和处理边界**：创建一个空列表存储有效三元组；排序输入数组（降序或升序均可）；数组长度小于 3 时直接返回空列表。
2. **遍历元素作为固定点**：遍历数组元素的位置 `i`（`i` 范围从 0 到 `nums.length - 2`）。
   - 跳过重复值以避免冗余结果：如果 `i > 0` 并且 `nums[i] === nums[i - 1]`，则跳过当前 `i` 继续下一次循环（除非数组仅有一个数字）。
   - 停止优化：如果 `nums[i] > target` 且数组升序排序（此时所有后续组合必超过 N），则可以提前结束。
3. **设置双指针搜索余下部分**：针对当前 `i` 对应的位置：
   - **左指针 `j`**： 设置为 `i + 1`，开始时紧跟当前固定的数右边。
   - **右指针 `k`**： 设置在数组末尾索引处（例如 `nums.length - 1`）。
4. **双指针移动逻辑**：在 `j < k` 前提下循环：
   - **计算当前三数和 `sum`**：即 `nums[i] + nums[j] + nums[k]`。
   - **处理三种情况**：
     - **如果 `sum == N`**：将 `[nums[i], nums[j], nums[k]]` 加入结果列表。然后移动左右指针：
        - 右移 `j`（左指针到右边搜索），确保跳过当前重复值：`while j < k && nums[j] == nums[j+1]: j +=1`。
        - 左移 `k`（右指针移向左邻），跳过重复值：`while j < k && nums[k] == nums[k-1]: k -=1`。
        - 之后同时将 `j +=1` 和 `k -=1` 缩小区间继续搜索。
     - **如果 `sum < N`**：因当前组合太慢过小，右移左指针 `j +=1` 以增加数字规模。
     - **如果 `sum > N`**：因组合超目标，左移右指针 `k -=1` 减小三数和以逼近目标。
5. **结束与返回**：遍历完所有可能的固定点后返回结果列表。总的时间复杂度是 O(n log n)(sort)+O(n×n)=O(n²)，空间为额外列表（至多为 O(n)）只记录输出。

使用 JavaScript 实现示例：
```javascript
function threeSum(nums, target) {
    // 结果数组存放 [a,b,c] 所有满足的 tuples
    let result = [];
    if (nums == null || nums.length < 3) return result;

    // Step0: 升序排序原始数组 
    nums.sort((a, b) => a - b);
    let n = nums.length;

    // 遍历固定每一个 numbers[i]
    for (let i = 0; i < n - 2; i++) {
        // 连续相同元素：从第二元素起忽略当前重复遍历
        if (i > 0 && nums[i] === nums[i - 1]) continue;

        // Step1:建立双指针区间：从剩余部分的左右两端开始查找组合关系组合。
        let j = i + 1; //指针在剩余部分的起始处 
        let k = n - 1; //在剩余的尾部指针索引

        while (j < k) {
            const currentSum = nums[i] + nums[j] + nums[k];
            if (currentSum === target) {
                result.push([nums[i], nums[j], nums[k]]);
                // 先收缩j k指针后再重复：移动j保证下一是未使用；同时移动k以避免重复。
                while (j < k && nums[j] === nums[j + 1]) j++;
                while (j < k && nums[k] === nums[k - 1]) k--;
                j++; //指针同时移动扩大继续下一个位置查找
                k--;
            } else if (currentSum < target) {
                j++;
            } else if (currentSum > target) {
                k--;
            }
        }
    }
    return result;
}

// 使用用例验证：例如找出所有和为10的三元组，在升序数组输入[1,2,3,4,5,6,7,8,9,10]。 
// const inputArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
// const targetValue = 10;
// console.log(threeSum(inputArray, targetValue)); 
// 将输出：[[1,2,7], [1,3,6], [1,4,5], [2,3,5]]
```

关键点说明：
- **时间与空间效率**：
  - 时间: O(n²) — 在排序后遍历数组需一层循环 O(n), 内嵌一个双指针滑动耗时约O(n)。
  - 空间复杂度：排除输出结果，使用常数级变量(O(1));如果包括输出数组，则最多有O(n²)个元素。
- **适用于动态数组问题**：此法亦可适应四元求和情况只需外固定另一个索引。
- 面试点关注：为什么排序是必要的？排序后的数组可以避免重复结果并提供双指针动态调整基础位置？
